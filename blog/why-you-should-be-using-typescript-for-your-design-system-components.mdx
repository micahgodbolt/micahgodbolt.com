---
date: 2019-10-24T04:07:22.198Z
title: Why you should be using Typescript for your design system components
---
The web community loves [TypeScript](https://www.typescriptlang.org/) right now. After working in complex applications environments, its pretty easy to see the benefits that it brings: less bugs, easier on-boarding, self documentation, improved refactoring. But you don't need to be an application developer to love typed languages, if you are building a Design System control library you owe it to your customers to user TypeScript! Here are some of the key reasons you want to be using TypeScript in your Design System controls.


## Improved usability

If you write you controls with typed interfaces, then it becomes much easier for consumers to use your controls without having to dig through piles of documentation. Here's a Card component that takes in a few simple props for its content, but also renders tags, which have their own props. 


```tsx

// Tag.tsx
import React from "react";

export interface TagProps {
   title: string;
   color?: string;
   onClick: (event: React.MouseEvent<HTMLElement> ) => void;
}

// Card.tsx 
import React from "react";
import {TagProps} from "./Tag.tsx";

export interface CardProps {
  title: string;
  description?: string;
  promoted?: boolean;
  tags?: TagProps[]; 
}

export Card = (props: CardProps) => {
  export (<div>...do stuff there...</div>)
}

```

Now that our Card has its props defined with TypeScript users will not only get much better intellisense (the editor telling you what props are available), but you'll also be warned if you are using the props incorrectly.

This will throw an error because "title" is required

```tsx
import React from "react";
import {Card, TagProps} from "your-awesome-design-system";

<Card description="Hi there" /> 
```

---

This will throw an error because Card expected a string for the title
```tsx
<Card title={['First paragraph', 'Second paragraph'} />
```

---

Types can be used to define data that will be passed into props. Here's the data for an array of Tags. If I leave out a title, or try to pass a second param in onClick, I'll get an error.

```tsx
const tags:TagProps[] = [
  { title: 'Tag1'}
  { title: 'Tag2', color: 'green', onClick: (event) => alert('clicked')}
  { color: 'red', onClick: (event, item) => alert(item.title) }
]
 
<Card title="Hello World" tags={tags}  /> 
```

 

## Easier documentation

Since component interfaces define the shape of the data passed into a control, they are a great source to derive documentation from. It's like [JSDoc](https://jsdoc.app/), but your docs are updated as soon as you make a change to your interface.

The way we do this on UI Fabric is with a utility called [API Extractor](https://api-extractor.com/). This is the same tool used by [Microsoft Docs](https://docs.microsoft.com/) and it lets us automatically turn this [Checkbox interface](https://github.com/OfficeDev/office-ui-fabric-react/blob/master/packages/office-ui-fabric-react/src/components/Checkbox/Checkbox.types.ts#L26) into [this documentation](https://developer.microsoft.com/en-us/fabric#/controls/web/checkbox#implementation). 


## Enforcing backwards compatibility

Another advantage of using API extractor is that we can use it to ensure that we aren't breaking backwards compatibility. Our promise is that we never remove or change
